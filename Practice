[I] INTRODUCTION

[II] CREATE A SIMPLE DART CLASS

	class Bicycle {
	int cadence;
	int speed;
	int gear;
	}

	void main() {  

	}

	Observations: 

	//  1.  Dart's main method is named main() or (if you need access to command line arguments) main(List<String> args).
	
	//  2. The main() method lives at the top level. In Dart, you can define code outside of classes. 
		Variables, functions, getters, and setters can all live outside of classes.

	//  3. The original Java example declares private instance variables using the private tag, which Dart doesn't use. 
		You'll learn more about privacy in "Step 3: Add a read-only variable".

	//  4. Neither main() nor Bicycle is declared as public, because all identifiers are public by default. 
		Dart doesn't have keywords for public, private, or protected.

	//  5. Dart uses 2-character indentation, by convention, instead of 4. 
		You don't need to worry about Dart's whitespace conventions, thanks to a handy tool called dartfmt. 
		As the Dart code conventions (Effective Dart) say, 
		"The official whitespace-handling rules for Dart are whatever dartfmt produces."

	DEFINING A BICYCLE CONSTRUCTOR:

	class Bicycle {
		int cadence;
		int speed;
		int gear;

		Bicycle(this.cadence, this.speed, this.gear);

	}

	Observations:

	// 1. This constructor has no body, which is valid in Dart.

	// 2. Using this in a constructor's parameter list is a handy shortcut for assigning values to instance variables.

	// 3. Constructor code in class Bicycle is equivalent to:

			Bicycle(int cadence, int speed, int gear) {
				this.cadence = cadence;
				this.speed = speed;
				this.gear = gear;
			}

	INSTANTIATE AND PRINT A BICYCLE INSTANCE:

	Add inside main(): 
			var bike = new Bicycle(2, 0, 1);   
			// You can remove the new Keyword as it has become optional from Dart 2
			print(bike);

	Observations:

	// 1. The new keyword became optional in Dart 2.

	// 2. If you know that a variable's value won't change, you can use final instead of var.

	TRY RUNNING THE EXAMPLE:

	O/P should be -->>  Instance of 'Bicycle

	Observations: No errors or warnings should appear, indicating that type inference is working, 
			and that the analyzer infers that var bike = ... defines a Bicycle instance.

	IMPROVE THE OUTPUT:

		While the output "Instance of ‘Bicycle'" is correct, it's not very informative. 
		All Dart classes have a toString() method that you can override to provide more useful output.

		Add the following toString() method anywhere in the Bicycle class:

		code: @override
				String toString() => 'Bicycle: $speed mph';

	Observations:

	// 1. The @override annotation tells the analyzer that you are intentionally overriding a member. 
		The analyzer raises an error if you've failed to perform the override properly.

	// 2. Dart supports single or double quotes when specifying strings.
	
	// 3. Use string interpolation to put the value of an expression inside a string literal: ${expression}. 
		If the expression is an identifier, you can skip the braces: $variableName.

	// 4. Shorten one-line functions or methods using fat arrow (=>) notation.


	ADD A READ-ONLY VARIABLE:

	The original Java example defines speed as a read-only variable—it declares it as private and provides only a getter. 
	Next, you'll provide the same functionality in Dart.'

	To mark a Dart identifier as private, start its name with an underscore (_).
	You can convert speed to read-only by changing its name and adding a getter.

	Make speed a private, read-only instance variable
	In the Bicycle constructor, remove the speed parameter:    -->>  Bicycle(this.cadence, this.gear);

	In main(), 
	remove the second (speed) parameter from the call to the Bicycle constructor:  -->>  var bike = Bicycle(2, 1);

	Change the remaining occurrences of speed to _speed. (2 places)

	Initialize _speed to 0:

	int _speed = 0;

	Add the following getter to the Bicycle class:

	int get speed => _speed;

	Observations: 

	// 1. Uninitialized variables (even numbers) have the value null.

	// 2. The Dart compiler enforces privacy for any identifier prefixed with an underscore.

	// 3. By default, Dart provides implicit getters and setters for all public instance variables. 
		You don't need to define your own getters/setters unless you want to enforce read-only or 
		write-only variables, compute or verify a value, or update a value elsewhere.

	// 4. Since getters and setters were provided for cadence and gear in the original Java example, 
		they aren't, by definition, considered private in the Dartiverse. 
		Those instance variables can be accessed using bike.gear or bike.cadence.

	// 5. You might start with a simple field, like bike.cadence, and later refactor it to use getters and setters. 
		The API stays the same. 
		In other words, going from a field to a getter/setter is not a breaking change in Dart.

	FINISH IMPLEMENTING SPEED AS A READ-ONLY INSTANCE VARIABLE:

	Add the following methods to the Bicycle class:

	void applyBrake(int decrement) {
	_speed -= decrement;
	}

	void speedUp(int increment) {
	_speed += increment;
	}

	The final Dart example looks similar to the original Java but is more compact at 23 lines instead of 40:

		CODE EXAMPLE 1

				class Bicycle {
				int cadence;
				int _speed = 0;
				int gear;
				
				Bicycle(this.cadence, this.gear);
				
				void applyBrake(int decrement) {
					_speed -= decrement;
				}
				
				void speedUp(int increment) {
					_speed += increment;
				}
				
				@override
				String toString() => 'Bicycle: $_speed mph';
				}
				
				void main() {
				var bike = Bicycle(2, 1);
				print(bike);
				}


[III] USE OPTIONAL PARAMETERS (instead of over loading): 
 
The next exercise defines a Rectangle class, another example from the Java Tutorial.

The Java code shows overloading constructors, a common practice in Java where constructors have the same name, but differ in the number or type of parameters. 
Dart doesn't support overloading constructors and handles this situation differently, as you will see in this section.

ADD A RECTANGLE CONSTRUCTOR

 Add a single, empty constructor that replaces all four constructors in the Java example:   -->>  Rectangle({this.origin = const Point(0, 0), this.width = 0, this.height = 0});
This constructor uses optional named parameters.

import 'dart:math';

class Rectangle {
  int width;
  int height;
  Point origin;
  
  Rectangle({this.origin = const Point(0, 0), this.width = 0, this.height = 0})
}

main() {} // Included main() to suppress uncaught exception.

Observations

// 1. this.origin, this.width, and this.height use the shorthand trick for assigning instance variables inside a constructor's declaration.

// 2. this.origin, this.width, and this.height are optional named parameters. Named parameters are enclosed in curly braces ({}).

// 3. The this.origin = const Point(0, 0) syntax specifies a default value of Point(0,0) for the origin instance variable. 
	  The specified default must be a compile-time constant. This constructor supplies default values for all three instance variables.


IMPROVE THE OUTPUT

 Add the following toString() function to the Rectangle class:  -->> @override
																			String toString () => 'Origin: (${origin.x}, ${origin.y}), width: $width, height: $height';

USE THE CONSTRUCTOR:

	  Replace main() with the following code to verify that you can instantiate Rectangle using only the parameters you need.

 code sample: main() {
				  print(Rectangle(origin: const Point(10, 20), width: 100, height: 200));
				  print(Rectangle(origin: const Point(10, 10)));
				  print(Rectangle(width: 200));
				  print(Rectangle());
				}

Observations: The Dart constructor for Rectangle is one line of code, compared to 16 lines of code for equivalent constructors in the Java version.

RUN THE EXAMPLE:

O/P:    Origin: (10, 20), width: 100, height: 200
		Origin: (10, 10), width: 0, height: 0
		Origin: (0, 0), width: 200, height: 0
		Origin: (0, 0), width: 0, height: 0


  CODE EXAMPLE 2: 

		import 'dart:math';
		
		class Rectangle {
		  int width;
		  int height;
		  Point origin;
		  
		  Rectangle({this.origin = const Point(0, 0), this.width = 0, this.height = 0});
		    
		  @override
		  String toString() => 'Origin: (${origin.x}, ${origin.y}, width: $width, height: $height)';
		}
		
		main() {
		  print(Rectangle(origin: const Point(10, 20), width: 100, height: 200));
		  print(Rectangle(origin: const Point(10, 10)));
		  print(Rectangle(width: 200));
		  print(Rectangle());
		} // Included main() to suppress uncaught exception.
		
		

[IV] CREATE A FACTORY:

Factories, a commonly used design pattern in Java, have several advantages over direct object instantiation, 
such as hiding the details of instantiation, providing the ability to return a subtype of the factory's 
return type, and optionally returning an existing object rather than a new object.

This step demonstrates two ways to implement a shape-creation factory:

Option 1: Create a top-level function
Option 2: Create a factory constructor
For this exercise, you'll use the Shapes example, which instantiates shapes and prints their computed area:

		import 'dart:math';

		abstract class Shape {
		num get area;
		}

		class Circle implements Shape {
		final num radius;
		Circle(this.radius);
		num get area => pi * pow(radius, 2);
		}

		class Square implements Shape {
		final num side;
		Square(this.side);
		num get area => pow(side, 2);
		}

		main() {
		final circle = Circle(2);
		final square = Square(2);
		print(circle.area);
		print(square.area);
		}

		O/P: 12.566370614359172
			 4

	Observations

	// 1. Dart supports abstract classes.

	// 2. You can define multiple classes in one file.

	// 3. dart.math is one of Dart's core libraries. Other core libraries include dart:core, dart:async, dart:convert, and dart:collection.

	// 4. In Dart 1.x, core library constants were uppercase (PI); in Dart 2, they're lowercase (pi).

	// 5. This code includes two getters that compute a value:

			num get area => pi * pow(radius, 2); // Circle
			num get area => pow(side, 2); // Square

4. a ) OPTION -1 CREATE A TOP LEVEL FUNCTION

	 Implement a factory as a top-level function by adding the following function 
	 at the highest level (outside of any class):

		Shape shapeFactory(String type) {
			if (type == 'circle') return Circle(2);
			if (type == 'square') return Square(2);
			throw 'Can\'t create $type.';
		}

	Invoke the factory function by replacing the first two lines in the main() method:

		final circle = shapeFactory('circle');
		final square = shapeFactory('square');

	Code:

		import 'dart:math';

		Shape shapeFactory(String type) {
				if (type == 'circle') return Circle(2);
				if (type == 'square') return Square(2);
				throw 'Can\'t create $type.';
		}

		abstract class Shape {
		num get area;
		}

		class Circle implements Shape {
		final num radius;
		Circle(this.radius);
		num get area => pi * pow(radius, 2);
		}

		class Square implements Shape {
		final num side;
		Square(this.side);
		num get area => pow(side, 2);
		}

		main() {
		final circle = shapeFactory('circle');
		final square = shapeFactory('square');
		print(circle.area);
		print(square.area);
		}

			O/P: 12.566370614359172
				 4

	Observations: 
	 // 1. If the function is called with any string other than 'circle' or 'square', it throws an exception.

	 // 2. The Dart SDK defines classes for many common exceptions, 
	 	   or you can extend the Exception class to create your own more specific exceptions 
	 	   or (as in this example) you can throw a string that describes the problem encountered.
	 
	 // 3. When an exception is encountered, DartPad reports Uncaught. 
	 	   To see information that's more helpful, wrap the code in a try-catch statement, 
		   and print the exception. 

	 // 4. To use a single quote inside a string, 
	       either escape the embedded quote using slash ('Can\'t create $type.') 
	 	   or specify the string with double quotes ("Can't create $type.").

	Code: 

		import 'dart:math';

		abstract class Shape {
		factory Shape(String type) {
			if (type == 'circle') return new Circle(2);
			if (type == 'square') return new Square(2);
			// To trigger exception, don't implement a check for 'triangle'.
			throw 'Can\'t create $type.';
		}
		num get area;
		}

		class Circle implements Shape {
		final num radius;
		Circle(this.radius);
		num get area => pi * pow(radius, 2);
		}

		class Square implements Shape {
		final num side;
		Square(this.side);
		num get area => pow(side, 2);
		}

		class Triangle implements Shape {
		final num side;
		Triangle(this.side);
		num get area => pow(side, 2) / 2;
		}

		main() {
		try {
			print(new Shape('circle').area);
			print(new Shape('square').area);
			print(new Shape('triangle').area);
		} catch (err) {
			print(err);
		}
		}

4. b ) OPTION -1 CREATE A FACTORY CONSTRUCTOR

	Use Dart's factory keyword to create a factory constructor.

	Add a factory constructor to the abstract Shape class

		abstract class Shape {
		factory Shape(String type) {
			if (type == 'circle') return Circle(2);
			if (type == 'square') return Square(2);
			throw 'Can\'t create $type.';
		}
		num get area;
		}

	Replace the first two lines of main() with the following code for instantiating the shapes:

		final circle = Shape('circle');
		final square = Shape('square');
 	
	 Delete the shapeFactory() function that you added previously.

	Code: 

	import 'dart:math';

	abstract class Shape {
	factory Shape(String type) {
		if (type == 'circle') return Circle(2);
		if (type == 'square') return Square(2);
		throw 'Can\'t create $type.';
	}
	num get area;
	}

	class Circle implements Shape {
	final num radius;
	Circle(this.radius);
	num get area => pi * pow(radius, 2);
	}

	class Square implements Shape {
	final num side;
	Square(this.side);
	num get area => pow(side, 2);
	}

	main() {
	final circle = Shape('circle');
	final square = Shape('square');
	print(circle.area);
	print(square.area);
	}

	Observation:
	The code in the factory constructor is identical to the code used in the shapeFactory() function.

[V] IMPLEMENT A INTERFACE
